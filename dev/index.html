<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · StaticTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://brenhinkeller.github.io/StaticTools.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StaticTools.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/brenhinkeller/StaticTools.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StaticTools"><a class="docs-heading-anchor" href="#StaticTools">StaticTools</a><a id="StaticTools-1"></a><a class="docs-heading-anchor-permalink" href="#StaticTools" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/brenhinkeller/StaticTools.jl">StaticTools</a>.</p><ul><li><a href="#Bumper.AllocBufferImpl.AllocBuffer"><code>Bumper.AllocBufferImpl.AllocBuffer</code></a></li><li><a href="#StaticTools.MallocArray"><code>StaticTools.MallocArray</code></a></li><li><a href="#StaticTools.MallocArray-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>StaticTools.MallocArray</code></a></li><li><a href="#StaticTools.MallocArray-Union{Tuple{N}, Tuple{T}, Tuple{UndefInitializer, Int64, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>StaticTools.MallocArray</code></a></li><li><a href="#StaticTools.MallocMatrix"><code>StaticTools.MallocMatrix</code></a></li><li><a href="#StaticTools.MallocSlabBuffer"><code>StaticTools.MallocSlabBuffer</code></a></li><li><a href="#StaticTools.MallocString-Tuple{UndefInitializer, Int64}"><code>StaticTools.MallocString</code></a></li><li><a href="#StaticTools.MallocString-Union{Tuple{Tuple{Vararg{UInt8, N}}}, Tuple{N}} where N"><code>StaticTools.MallocString</code></a></li><li><a href="#StaticTools.MallocString"><code>StaticTools.MallocString</code></a></li><li><a href="#StaticTools.MallocVector"><code>StaticTools.MallocVector</code></a></li><li><a href="#StaticTools.SplitMix64"><code>StaticTools.SplitMix64</code></a></li><li><a href="#StaticTools.StackArray-Union{Tuple{T}, Tuple{UndefInitializer, Vararg{Int64}}} where T"><code>StaticTools.StackArray</code></a></li><li><a href="#StaticTools.StackArray"><code>StaticTools.StackArray</code></a></li><li><a href="#StaticTools.StackArray-Tuple{Tuple{Vararg{T, N}} where {N, T}, Vararg{Int64}}"><code>StaticTools.StackArray</code></a></li><li><a href="#StaticTools.StackMatrix"><code>StaticTools.StackMatrix</code></a></li><li><a href="#StaticTools.StackVector"><code>StaticTools.StackVector</code></a></li><li><a href="#StaticTools.StaticString"><code>StaticTools.StaticString</code></a></li><li><a href="#StaticTools.StaticString-Tuple{AbstractString}"><code>StaticTools.StaticString</code></a></li><li><a href="#StaticTools.Xoshiro256✴︎✴︎"><code>StaticTools.Xoshiro256✴︎✴︎</code></a></li><li><a href="#Base.iterate"><code>Base.iterate</code></a></li><li><a href="#Base.nextind"><code>Base.nextind</code></a></li><li><a href="#Base.parse-Tuple{Type{Float64}, AbstractStaticString}"><code>Base.parse</code></a></li><li><a href="#Base.prevind"><code>Base.prevind</code></a></li><li><a href="#Base.read-Tuple{Ptr{StaticTools.FILE}, Type{UInt8}}"><code>Base.read</code></a></li><li><a href="#Base.read-Tuple{Ptr{StaticTools.FILE}, Type{MallocString}}"><code>Base.read</code></a></li><li><a href="#Base.read-Tuple{AbstractStaticString, Type{&lt;:Union{MallocString, MallocArray}}}"><code>Base.read</code></a></li><li><a href="#Base.readline-Tuple{Ptr{StaticTools.FILE}}"><code>Base.readline</code></a></li><li><a href="#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{MallocArray}, Type{MallocArray{T}}, Type{MallocArray{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>Base.unsafe_wrap</code></a></li><li><a href="#StaticTools.:⅋-Tuple{Any}"><code>StaticTools.:⅋</code></a></li><li><a href="#StaticTools.calloc-Tuple{Integer}"><code>StaticTools.calloc</code></a></li><li><a href="#StaticTools.dlclose-Tuple{Ptr{StaticTools.DYLIB}}"><code>StaticTools.dlclose</code></a></li><li><a href="#StaticTools.dlopen"><code>StaticTools.dlopen</code></a></li><li><a href="#StaticTools.dlsym-Tuple{Ptr{StaticTools.DYLIB}, Union{MallocString, MallocArray}}"><code>StaticTools.dlsym</code></a></li><li><a href="#StaticTools.fclose-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.fclose</code></a></li><li><a href="#StaticTools.fopen-Tuple{Union{MallocString, MallocArray}, Union{MallocString, MallocArray}}"><code>StaticTools.fopen</code></a></li><li><a href="#StaticTools.fread!-Tuple{Any, AbstractString, Vararg{Any}}"><code>StaticTools.fread!</code></a></li><li><a href="#StaticTools.free-Tuple{Ptr}"><code>StaticTools.free</code></a></li><li><a href="#StaticTools.fseek"><code>StaticTools.fseek</code></a></li><li><a href="#StaticTools.ftell-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.ftell</code></a></li><li><a href="#StaticTools.fwrite-Tuple{AbstractString, Vararg{Any}}"><code>StaticTools.fwrite</code></a></li><li><a href="#StaticTools.getc-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.getc</code></a></li><li><a href="#StaticTools.getchar-Tuple{}"><code>StaticTools.getchar</code></a></li><li><a href="#StaticTools.gets!"><code>StaticTools.gets!</code></a></li><li><a href="#StaticTools.malloc-Tuple{Integer}"><code>StaticTools.malloc</code></a></li><li><a href="#StaticTools.memcmp-Tuple{Any, Any, Int64}"><code>StaticTools.memcmp</code></a></li><li><a href="#StaticTools.memcpy!-Tuple{Any, Any}"><code>StaticTools.memcpy!</code></a></li><li><a href="#StaticTools.memset!"><code>StaticTools.memset!</code></a></li><li><a href="#StaticTools.meye-Tuple{Int64}"><code>StaticTools.meye</code></a></li><li><a href="#StaticTools.mfill-Tuple{Any, Vararg{Int64}}"><code>StaticTools.mfill</code></a></li><li><a href="#StaticTools.mones-Tuple"><code>StaticTools.mones</code></a></li><li><a href="#StaticTools.mzeros-Tuple{Vararg{Int64}}"><code>StaticTools.mzeros</code></a></li><li><a href="#StaticTools.newline-Tuple{}"><code>StaticTools.newline</code></a></li><li><a href="#StaticTools.parsedlm-Tuple{Any, Char}"><code>StaticTools.parsedlm</code></a></li><li><a href="#StaticTools.perror-Tuple{MallocString}"><code>StaticTools.perror</code></a></li><li><a href="#StaticTools.printdlm"><code>StaticTools.printdlm</code></a></li><li><a href="#StaticTools.printf-Tuple{MallocString}"><code>StaticTools.printf</code></a></li><li><a href="#StaticTools.printf-Union{Tuple{Tuple{T1, T2}}, Tuple{T2}, Tuple{T1}} where {T1, T2}"><code>StaticTools.printf</code></a></li><li><a href="#StaticTools.printf-Tuple{T} where T&lt;:Union{Number, Ptr}"><code>StaticTools.printf</code></a></li><li><a href="#StaticTools.printf-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{Number, Ptr, StaticString}"><code>StaticTools.printf</code></a></li><li><a href="#StaticTools.putchar-Tuple{Char}"><code>StaticTools.putchar</code></a></li><li><a href="#StaticTools.puts-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.puts</code></a></li><li><a href="#StaticTools.seye-Tuple{Int64}"><code>StaticTools.seye</code></a></li><li><a href="#StaticTools.sfill-Tuple{Any, Vararg{Int64}}"><code>StaticTools.sfill</code></a></li><li><a href="#StaticTools.sones-Tuple"><code>StaticTools.sones</code></a></li><li><a href="#StaticTools.splitmix64"><code>StaticTools.splitmix64</code></a></li><li><a href="#StaticTools.static_rng"><code>StaticTools.static_rng</code></a></li><li><a href="#StaticTools.static_type-Tuple{Any}"><code>StaticTools.static_type</code></a></li><li><a href="#StaticTools.static_type_contents-Tuple{Any}"><code>StaticTools.static_type_contents</code></a></li><li><a href="#StaticTools.stderrp-Tuple{}"><code>StaticTools.stderrp</code></a></li><li><a href="#StaticTools.stdinp-Tuple{}"><code>StaticTools.stdinp</code></a></li><li><a href="#StaticTools.stdoutp-Tuple{}"><code>StaticTools.stdoutp</code></a></li><li><a href="#StaticTools.strlen-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strlen</code></a></li><li><a href="#StaticTools.strtod-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtod</code></a></li><li><a href="#StaticTools.strtol-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtol</code></a></li><li><a href="#StaticTools.strtoul-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtoul</code></a></li><li><a href="#StaticTools.system-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.system</code></a></li><li><a href="#StaticTools.szeros-Tuple"><code>StaticTools.szeros</code></a></li><li><a href="#StaticTools.time-Tuple{}"><code>StaticTools.time</code></a></li><li><a href="#StaticTools.usleep-Tuple{Integer}"><code>StaticTools.usleep</code></a></li><li><a href="#StaticTools.xoshiro256✴︎✴︎-Tuple{StaticTools.StaticRNG{4}}"><code>StaticTools.xoshiro256✴︎✴︎</code></a></li><li><a href="#StaticTools.@c_str-Tuple{Any}"><code>StaticTools.@c_str</code></a></li><li><a href="#StaticTools.@externload-Tuple{Any}"><code>StaticTools.@externload</code></a></li><li><a href="#StaticTools.@externptr-Tuple{Any}"><code>StaticTools.@externptr</code></a></li><li><a href="#StaticTools.@m_str-Tuple{Any}"><code>StaticTools.@m_str</code></a></li><li><a href="#StaticTools.@ptrcall-Tuple{Any}"><code>StaticTools.@ptrcall</code></a></li><li><a href="#StaticTools.@symbolcall-Tuple{Any}"><code>StaticTools.@symbolcall</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Bumper.AllocBufferImpl.AllocBuffer" href="#Bumper.AllocBufferImpl.AllocBuffer"><code>Bumper.AllocBufferImpl.AllocBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllocBuffer(::Type{MallocVector}, n::Int=1048576)</code></pre><p>Create an <code>AllocBuffer</code> backed by a <code>MallocArray</code>. This buffer should be manually <code>free</code> once you&#39;re done with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/bumper.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocArray" href="#StaticTools.MallocArray"><code>StaticTools.MallocArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MallocArray{T,N} &lt;: DenseArray{T,N} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>-dimensional dense heap-allocated array with elements of type <code>T</code>.</p><p>Much like <code>Base.Array</code>, except (1) backed by memory that is not tracked by the Julia garbage collector (is directly allocated with <code>malloc</code>) so is StaticCompiler-safe, (2) should be <code>free</code>d when no longer in use, and (3) contiguous slice indexing returns <code>ArrayView</code>s rather than copies.</p><p>Indexing a <code>MallocArray</code> out of bounds does not throw a <code>BoundsError</code>; much as if <code>@inbounds</code> were enabled, indexing a <code>MallocArray</code> incurs a strict promise by the programmer that the specified index is inbounds. Breaking this promise will result in segfaults or memory corruption.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocArray-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#StaticTools.MallocArray-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>StaticTools.MallocArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MallocArray(data::AbstractArray{T,N})</code></pre><p>Construct a <code>MallocArray</code> of eltype <code>T</code> from an existing <code>AbstractArray</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; a = szeros(Int, 5,5)
5×5 StackMatrix{Int64, 25, (5, 5)}:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0

julia&gt; MallocArray(a)
5×5 MallocMatrix{Int64}:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L150-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocArray-Union{Tuple{N}, Tuple{T}, Tuple{UndefInitializer, Int64, Tuple{Vararg{Int64, N}}}} where {T, N}" href="#StaticTools.MallocArray-Union{Tuple{N}, Tuple{T}, Tuple{UndefInitializer, Int64, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>StaticTools.MallocArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MallocArray(T, dims) do A
    ...
end</code></pre><pre><code class="language-julia hljs">MallocArray{T}(undef, dims)
MallocArray{T,N}(undef, dims)</code></pre><pre><code class="language-julia hljs">MallocArray{T}(zeros, dims)
MallocArray{T,N}(zeros, dims)</code></pre><p>Construct an uninitialized (<code>undef</code>) or zero-initialized (<code>zeros</code>) <code>N</code>-dimensional <code>MallocArray</code> containing elements of type <code>T</code>. <code>N</code> can either be supplied explicitly, as in <code>Array{T,N}(undef, dims)</code>, or be determined by the length or number of <code>dims</code>. <code>dims</code> may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank <code>N</code> is supplied explicitly, then it must match the length or number of <code>dims</code>.</p><p>Here <code>undef</code> is the <code>UndefInitializer</code> and signals that <code>malloc</code> should be used to obtain the underlying memory, while <code>zeros</code> is the <code>Base</code> function <code>zeros</code> and flags that <code>calloc</code> should be used to obtain and zero-initialize the underlying memory.</p><p>Attempting to create a <code>MallocArray</code> with dimensions larger than can be successfully allocated will return an empty <code>MallocArray</code> with size 0 in all dimensions and pointer null.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; A = MallocArray{Float64}(undef, 3,3) # implicit N
3×3 MallocMatrix{Float64}:
 3.10504e231   6.95015e-310   2.12358e-314
 1.73061e-77   6.95015e-310   5.56271e-309
 6.95015e-310  0.0           -1.29074e-231

julia&gt; free(A)
0

julia&gt; A = MallocArray{Float64, 3}(zeros, 2,2,2) # explicit N, zero initialize
2×2×2 MallocArray{Float64, 3}:
[:, :, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2] =
 0.0  0.0
 0.0  0.0

julia&gt; free(A)
0</code></pre><p>To avoid having to manually <code>free</code> allocated memory, it is recommended to use the following supported do-block syntax whenever possible, i.e.</p><pre><code class="language-julia hljs">julia&gt; MallocArray(Float64, 2, 2) do A
           A .= 0
           printf(A)
       end
0.000000e+00    0.000000e+00
0.000000e+00    0.000000e+00
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L44-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocMatrix" href="#StaticTools.MallocMatrix"><code>StaticTools.MallocMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MallocMatrix{T} &lt;: AbstractMatrix{T}</code></pre><p>Two-dimensional dense heap-allocated array with elements of type <code>T</code>. As <code>Base.Matrix</code> is to <code>Base.Array</code>, but with <code>MallocArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocSlabBuffer" href="#StaticTools.MallocSlabBuffer"><code>StaticTools.MallocSlabBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MallocSlabBuffer(;slab_size::Int = 1_048_576, slabs_max_length::Int=8, custom_slabs_max_length::Int=64)</code></pre><p>A StaticCompiler.jl friendly version of <code>SlabBuffer</code> from <a href="https://github.com/MasonProtter/Bumper.jl">Bumper.jl</a>. This should be the preferred way to manage dynamically sized memory without support from the julia runtime.</p><p><code>MallocSlabBuffer</code> is what&#39;s known as a slab-based bump allocator. It stores a list of fixed size memory &#39;slabs&#39; (of size <code>slab_size</code> bytes), and memory can be requested from those slabs very fast. For allocations larger than half the <code>slab_size</code>, we do a size-specific <code>malloc</code> call and store the pointer in a separate list of custom sized slabs. At the end of a <code>@no_escape</code> block (see <a href="https://github.com/MasonProtter/Bumper.jl">Bumper.jl</a>), any unneeded slabs (custom or fixed-size) are <code>free</code>d.</p><p>The keyword arguments <code>slabs_max_length</code> and <code>custom_slabs_max_length</code> determine how many slabs and custom slabs the allocator is set to be able to initially store. If you dynamically allocate more slabs or custom slabs than these parameters, the <code>MallocSlabBuffer</code> will automatically resize itself to be able to store more slabs. These parameters are just heuristics for the initial creation of the allocator.</p><p><code>MallocSlabBuffer</code>s should be freed once you are done with them.</p><hr/><p>Example usage:</p><pre><code class="nohighlight hljs">function slab_benchmark(argc::Int, argv::Ptr{Ptr{UInt8}})
    argc == 2 || return printf(c&quot;Incorrect number of command-line arguments</code></pre><p>&quot;)         Nevals = argparse(Int64, argv, 2) # First command-line argument         # Create a slab buffer         buf = MallocSlabBuffer()         @no<em>escape buf begin             # Create some vector x of length 10 containing all 1s.             x = @alloc(Int, 10)             x .= 1             for i ∈ 1:Nevals                 # Start a new no</em>escape block so that allocations created during this                 # block get freed up at the end                 @no<em>escape buf begin                     # Do some allocating operations in the loop                     y = @alloc(Int, 10)                     y .= x .+ 1                     # It&#39;s vital that we never allow an array created by alloc to ever                     # escape a @no</em>escape block!                     sum(y)                  end             end             nothing         end         # release the buffer once you&#39;re done with it.         free(buf)     end</p><pre><code class="nohighlight hljs">julia&gt; compile_executable(slab_benchmark, (Int64, Ptr{Ptr{UInt8}}), &quot;./&quot;);

shell&gt; time ./slab_benchmark 1000000000
real    0m2.417s
user    0m2.408s
sys     0m0.000s</code></pre><hr/><p>Implementation notes:</p><ul><li>MallocSlabBuffer stores a pointer to a <code>MallocSlabBufferData</code> so it can mutate the object without being a <code>mutable</code> type.</li><li>It stores a set of memory &quot;slabs&quot; of size <code>slab_size</code> (default 1 megabyte). </li><li>the <code>current</code> field is the currently active pointer that a newly <code>@alloc</code>&#39;d object will aquire, if the object fits between <code>current</code> and <code>slab_end</code>.</li><li>If the object does not fit between <code>current</code> and <code>slab_end</code>, but is smaller than <code>slab_size</code>, we&#39;ll <code>malloc</code> a new slab,  and add it to <code>slabs</code> (reallocating the <code>slabs</code> pointer if there&#39;s not enough room, as determined by <code>max_slabs_length</code>) and then set that thing as the <code>current</code> pointer, and provide that to the object.</li><li>If the object is bigger than <code>slab_size</code>, then we <code>malloc</code> a pointer of the requested size, and add it to the <code>custom_slabs</code> pointer  (also reallocating that pointer if necessary), leaving <code>current</code> and <code>slab_end</code> unchanged.</li><li>When a <code>@no_escape</code> block ends, we reset <code>current</code>, and <code>slab_end</code> to their old values, and if <code>slabs</code> or <code>custom_slabs</code> have grown, we <code>free</code> all the pointers that weren&#39;t present before, and reset their respective <code>length</code>s (but not <code>max_size</code>s).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/bumper.jl#L40-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocString" href="#StaticTools.MallocString"><code>StaticTools.MallocString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MallocString
    pointer::Ptr{UInt8}
    length::Int
end</code></pre><p>A stringy object that contains <code>length</code> bytes (i.e., <code>UInt8</code>s, including the final null-termination <code>0x00</code>), at a location in memory specified by <code>pointer</code>.</p><p>A <code>MallocString</code> should generally behave like a base Julia <code>String</code>, but is explicitly null-terminated, mutable, standalone-StaticCompiler-safe (does not require libjulia) and backed by <code>malloc</code>ed memory which is not tracked by the GC and should be <code>free</code>d when no longer in use.</p><p>Can be constructed with the <code>m&quot;...&quot;</code> string macro.</p><p>Unlike base Julia <code>String</code>s, slicing does not create a copy, but rather a view. You are responsible for ensuring that any such views are null-terminated if you wish to pass them to any functions (including most libc/system IO) that expect null-termination.</p><p>Indexing a <code>MallocString</code> out of bounds does not throw a <code>BoundsError</code>; much as if <code>@inbounds</code> were enabled, indexing a <code>MallocString</code> incurs a strict promise by the programmer that the specified index is inbounds. Breaking this promise will result in segfaults or memory corruption.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = m&quot;Hello world!&quot;
m&quot;Hello world!&quot;

julia&gt; s[8:12] = c&quot;there&quot;; s
m&quot;Hello there!&quot;

julia&gt; s[1:5]
StringView: &quot;Hello&quot;

julia&gt; s[1:5] == &quot;Hello&quot;
true

julia&gt; StaticString(s[1:5])
c&quot;Hello&quot;

julia&gt; free(s)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocstring.jl#L6-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocString-Tuple{UndefInitializer, Int64}" href="#StaticTools.MallocString-Tuple{UndefInitializer, Int64}"><code>StaticTools.MallocString</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MallocString(undef, N)</code></pre><p>Construct an uninitialized <code>N</code>-byte (including null-termination!) <code>MallocString</code>. Here <code>undef</code> is the <code>UndefInitializer</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = MallocString(undef, 10)
m&quot;&quot;

julia&gt; free(s)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocstring.jl#L60-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocString-Union{Tuple{Tuple{Vararg{UInt8, N}}}, Tuple{N}} where N" href="#StaticTools.MallocString-Union{Tuple{Tuple{Vararg{UInt8, N}}}, Tuple{N}} where N"><code>StaticTools.MallocString</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MallocString(data::NTuple{N, UInt8})</code></pre><p>Construct a <code>MallocString</code> containing the <code>N</code> bytes specified by <code>data</code>. To yield a valid string, <code>data</code> must be null-terminated, i.e., end in <code>0x00</code>.</p><pre><code class="language-julia hljs">MallocString(s::AbstractStaticString)</code></pre><p>Construct a <code>MallocString</code> containing the same data as the existing string <code>s</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; data = (0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00);

julia&gt; s = MallocString(data)
m&quot;Hello world!&quot;

julia&gt; s2 = MallocString(s[1:5])
m&quot;Hello&quot;

julia&gt; free(s)
0

julia&gt; free(s2)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocstring.jl#L81-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.MallocVector" href="#StaticTools.MallocVector"><code>StaticTools.MallocVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MallocVector{T} &lt;: AbstractVector{T}</code></pre><p>Two-dimensional dense heap-allocated array with elements of type <code>T</code>. As <code>Base.Vector</code> is to <code>Base.Array</code>, but with <code>MallocArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.SplitMix64" href="#StaticTools.SplitMix64"><code>StaticTools.SplitMix64</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplitMix64([seed::Bits64])</code></pre><p>Initialize the internal state of a StaticCompiler-safe (non-allocating) <code>SplitMix64</code> deterministic pseudorandom number generator, optionally specifying a 64-bit <code>seed</code> (which may be a <code>Float64</code>, <code>Int64</code>, or <code>UInt64</code>).</p><p>If a seed is not specified, <code>StaticTools.time()</code> will be used, which returns the current Unix epoch time in seconds.</p><p><strong>See also:</strong></p><p><code>splitmix64</code>, <code>rand</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; seed = StaticTools.time() # Pick a seed
1649890154

julia&gt; rng = SplitMix64(seed) # Initialize the generator
SplitMix64{Int64}((1649890154,))

julia&gt; splitmix64(rng) # Draw a pseudorandom `UInt64` from the generator
0xca764ac7b7ea31e8

julia&gt; rand(rng) # Draw a `Float64` between 0 and 1
0.8704883051360292</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticrng.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StackArray" href="#StaticTools.StackArray"><code>StaticTools.StackArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackArray{T,N,L,D} &lt;: DenseTupleArray{T,N,L,D} &lt;: DenseStaticArray{T,N} &lt;: DenseArray{T,N} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>-dimensional dense stack-allocated array with elements of type <code>T</code>.</p><p>Much like <code>Base.Array</code>, except (1) backed by memory that is not tracked by the Julia garbage collector (is stack allocated by <code>alloca</code>), so is StaticCompiler-friendly, and (2) contiguous slice indexing returns <code>ArrayView</code>s rather than copies.</p><p>Indexing a <code>StackArray</code> out of bounds does not throw a <code>BoundsError</code>; much as if <code>@inbounds</code> were enabled, indexing a <code>StackArray</code> incurs a strict promise by the programmer that the specified index is inbounds. Breaking this promise will result in segfaults or memory corruption.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StackArray-Tuple{Tuple{Vararg{T, N}} where {N, T}, Vararg{Int64}}" href="#StaticTools.StackArray-Tuple{Tuple{Vararg{T, N}} where {N, T}, Vararg{Int64}}"><code>StaticTools.StackArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StackArray(data::NTuple{L,T})
StackArray(data::NTuple{L,T}, dims)
StackArray(data::AbstractArray{T,N})</code></pre><p>Construct a <code>StackArray</code> with eltype <code>T</code> from an existing <code>Tuple</code> or <code>AbstractArray</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; a = ntuple(i-&gt;0, 25)
(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

julia&gt; StackArray(a, 5,5)
5×5 StackMatrix{Int64, 25, (5, 5)}:
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0
 0  0  0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L95-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StackArray-Union{Tuple{T}, Tuple{UndefInitializer, Vararg{Int64}}} where T" href="#StaticTools.StackArray-Union{Tuple{T}, Tuple{UndefInitializer, Vararg{Int64}}} where T"><code>StaticTools.StackArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StackArray{T}(undef, dims)
StackArray{T,N}(undef, dims)
StackArray{T,N,L,D}(undef)</code></pre><p>Construct an uninitialized <code>N</code>-dimensional <code>StackArray</code> containing elements of type <code>T</code> with <code>N</code> dimensions, length <code>L</code> and dimensions <code>D</code>. Dimensionality <code>N</code> can either be supplied explicitly, as in <code>Array{T,N}(undef, dims)</code>, or be determined by the length or number of <code>dims</code>. <code>dims</code> may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank <code>N</code> is supplied explicitly, then it must match the length or number of <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; StackArray{Float64}(undef, 3,3)
3×3 StackMatrix{Float64, 9, (3, 3)}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L67-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StackMatrix" href="#StaticTools.StackMatrix"><code>StaticTools.StackMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackMatrix{T} &lt;: AbstractMatrix{T}</code></pre><p>Two-dimensional dense stack-allocated array with elements of type <code>T</code>. As <code>Base.Matrix</code> is to <code>Base.Array</code>, but with <code>StackArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StackVector" href="#StaticTools.StackVector"><code>StaticTools.StackVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackVector{T} &lt;: AbstractVector{T}</code></pre><p>Two-dimensional dense stack-allocated array with elements of type <code>T</code>. As <code>Base.Vector</code> is to <code>Base.Array</code>, but with <code>StackArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StaticString" href="#StaticTools.StaticString"><code>StaticTools.StaticString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticString{N}</code></pre><p>A stringy type which should generally behave like a base Julia <code>String</code>, but is explicitly null-terminated, mutable, and standalone-StaticCompiler safe (does not require libjulia).</p><p>Can be constructed with the <code>c&quot;...&quot;</code> string macro.</p><p>Unlike base Julia <code>String</code>s, slicing does not create a copy, but rather a view. You are responsible for ensuring that any such views are null-terminated if you wish to pass them to any functions (including most system IO) that expect null-termination.</p><p>Indexing a <code>StaticString</code> out of bounds does not throw a <code>BoundsError</code>; much as if <code>@inbounds</code> were enabled, indexing a <code>StaticString</code> incurs a strict promise by the programmer that the specified index is inbounds. Breaking this promise will result in segfaults or memory corruption.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = c&quot;Hello world!&quot;
c&quot;Hello world!&quot;

julia&gt; s[8:12] = c&quot;there&quot;; s
c&quot;Hello there!&quot;

julia&gt; s[1:5]
StringView: &quot;Hello&quot;

julia&gt; s[1:5] == &quot;Hello&quot;
true

julia&gt; StaticString(s[1:5])
c&quot;Hello&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticstring.jl#L6-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.StaticString-Tuple{AbstractString}" href="#StaticTools.StaticString-Tuple{AbstractString}"><code>StaticTools.StaticString</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">StaticString{N}(undef)</code></pre><p>Construct an uninitialized <code>N</code>-byte <code>StaticString</code></p><pre><code class="language-julia hljs">StaticString(data::NTuple{N,UInt8})</code></pre><p>Construct a <code>StaticString</code> containing the <code>N</code> bytes specified by <code>data</code>. To yield a valid string, <code>data</code> must be null-terminated, i.e., end in <code>0x00</code>.</p><pre><code class="language-julia hljs">StaticString(s::AbstractStaticString)</code></pre><p>Construct a <code>StaticString</code> containing the same data as the input string <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; data = (0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x00);

julia&gt; s = StaticString(data)
c&quot;Hello world!&quot;

julia&gt; StaticString(s[1:5])
c&quot;Hello&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticstring.jl#L54-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.Xoshiro256✴︎✴︎" href="#StaticTools.Xoshiro256✴︎✴︎"><code>StaticTools.Xoshiro256✴︎✴︎</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Xoshiro256✴︎✴︎(seed::NTuple{4,Bits64})</code></pre><p>Initialize the internal state of a StaticCompiler-safe (non-allocating) <code>Xoshiro256✴︎✴︎</code> deterministic pseudorandom number generator, specifying a 256-bit <code>seed</code>, which should be specified as an <code>NTuple</code> of four 64-bit numbers (all either <code>Float64</code>, <code>Int64</code>, or <code>UInt64</code>).</p><p><strong>See also:</strong></p><p><code>xoshiro256✴︎✴︎</code>, <code>static_rng</code>, <code>rand</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; seed = (0x9b134eccd2e63538, 0xd74ab64b2c3ecc9b, 0x70ba9c07628c27bf, 0x270a2eb658e6130b)
(0x9b134eccd2e63538, 0xd74ab64b2c3ecc9b, 0x70ba9c07628c27bf, 0x270a2eb658e6130b)

julia&gt; rng = Xoshiro256✴︎✴︎(seed) # Initialize the generator
Xoshiro256✴︎✴︎{UInt64}((0x9b134eccd2e63538, 0xd74ab64b2c3ecc9b, 0x70ba9c07628c27bf, 0x270a2eb658e6130b))

julia&gt; xoshiro256✴︎✴︎(rng) # Draw a pseudorandom `UInt64` from the generator
0x11059b6384fba06a

julia&gt; rand(rng) # Draw a `Float64` between 0 and 1
0.9856766307398369</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticrng.jl#L81-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate(s::AbstractStaticString, i=firstindex(s))</code></pre><p>Adapted form Julia&#39;s stdlib.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = c&quot;foo&quot;
c&quot;foo&quot;

julia&gt; iterate(s, 1)
(&#39;f&#39;, 2)

julia&gt; iterate(s, 99999)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/abstractstaticstring.jl#L131-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextind" href="#Base.nextind"><code>Base.nextind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nextind(s::AbstractString, i::Int, n::Int=1) -&gt; Int</code></pre><p>Adapted form Julia&#39;s stdlib, but made type-stable.</p><div class="admonition is-warning"><header class="admonition-header">Type-stability and exceptions</header><div class="admonition-body"><p>The interface is a bit different from <code>Base</code>. To make it compile-able, we need to remove all throw cases. The method behaves as close as it can from the original.</p><p>The method won&#39;t throw <code>BoundsError</code> anymore, but will return the closest index (0 or <code>ncodeunits(s)+1</code>).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextind(c&quot;α&quot;, 0)
1
julia&gt; nextind(c&quot;α&quot;, 1)
3
julia&gt; nextind(c&quot;α&quot;, 3)
3
julia&gt; nextind(c&quot;α&quot;, 0, 2)
3
julia&gt; nextind(c&quot;α&quot;, 1, 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/abstractstaticstring.jl#L236-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Tuple{Type{Float64}, AbstractStaticString}" href="#Base.parse-Tuple{Type{Float64}, AbstractStaticString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(::Type{T}, s::Union{StaticString, MallocString})</code></pre><p>Parse a number from a <code>StaticString</code> or <code>MallocString</code> <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; parse(Float64, c&quot;3.141592&quot;)
3.141592

julia&gt; parse(Int64, c&quot;3.141592&quot;)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L534-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevind" href="#Base.prevind"><code>Base.prevind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prevind(str::AbstractStaticString, i::Integer, n::Integer=1) -&gt; Int</code></pre><p>Adapted form Julia&#39;s stdlib, but made type-stable.</p><div class="admonition is-warning"><header class="admonition-header">Type-stability and exceptions</header><div class="admonition-body"><p>The interface is a bit different from <code>Base</code>. To make it compile-able, we need to remove all throw cases. The method behaves as close as it can from the original.</p><p>The method won&#39;t throw <code>BoundsError</code> anymore, but will return the closest index (0 or <code>ncodeunits(s)+1</code>).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prevind(c&quot;α&quot;, 3)
1
julia&gt; prevind(c&quot;α&quot;, 1)
0
julia&gt; prevind(c&quot;α&quot;, 0)
0
julia&gt; prevind(c&quot;α&quot;, 2, 2)
0
julia&gt; prevind(c&quot;α&quot;, 2, 3)
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/abstractstaticstring.jl#L197-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{AbstractStaticString, Type{&lt;:Union{MallocString, MallocArray}}}" href="#Base.read-Tuple{AbstractStaticString, Type{&lt;:Union{MallocString, MallocArray}}}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(filename::AbstractStaticString, MallocString)
read(filename::AbstractStaticString, MallocArray{T})</code></pre><p>Read <code>filename</code> in its entirety to a <code>MallocString</code> or <code>MallocArray{T}</code> with eltype <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L898-L905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{Ptr{StaticTools.FILE}, Type{MallocString}}" href="#Base.read-Tuple{Ptr{StaticTools.FILE}, Type{MallocString}}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(fp::Ptr{FILE}, MallocString)
read(fp::Ptr{FILE}, MallocArray{T})</code></pre><p>Read <code>fp</code> in its entirety to a <code>MallocString</code> or <code>MallocArray{T}</code> with eltype <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L913-L920">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{Ptr{StaticTools.FILE}, Type{UInt8}}" href="#Base.read-Tuple{Ptr{StaticTools.FILE}, Type{UInt8}}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(fp::Ptr{FILE}, UInt8)</code></pre><p>Read a single byte (as a single <code>UInt8</code>) from file pointer <code>fp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L890-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readline-Tuple{Ptr{StaticTools.FILE}}" href="#Base.readline-Tuple{Ptr{StaticTools.FILE}}"><code>Base.readline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readline(fp::Ptr{FILE})</code></pre><p>Read characters from file pointer <code>fp</code> until a unix newline ( ) is encountered and copy the results to a <code>MallocString</code></p><p>See also <code>readline!</code> / <code>gets!</code> for a more efficient in-place version.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.txt&quot;, c&quot;w+&quot;)
Ptr{FILE} @0x00007fffb05f1148

julia&gt; printf(fp, c&quot;Here is a line of text!&quot;)
23

julia&gt; frewind(fp)
0

julia&gt; readline(fp)
m&quot;Here is a line of text!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L713-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{MallocArray}, Type{MallocArray{T}}, Type{MallocArray{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}" href="#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{MallocArray}, Type{MallocArray{T}}, Type{MallocArray{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>Base.unsafe_wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_wrap(MallocArray, ptr::Ptr{T}, dims)</code></pre><p>Create a <code>MallocArray{T}</code> wrapping around <code>ptr</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.:⅋-Tuple{Any}" href="#StaticTools.:⅋-Tuple{Any}"><code>StaticTools.:⅋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">⅋(x)</code></pre><p>A convenience function to obtain the most relevant properly-typed pointer available for a given object or reference.</p><p>&quot;⅋&quot; can be typed at the repl as <code>\upand&lt;tab&gt;</code>.</p><pre><code class="language-julia hljs">julia&gt; x = Ref(1)
Base.RefValue{Int64}(1)

julia&gt; ⅋(x)
Ptr{Int64} @0x000000015751af00</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvminterop.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.calloc-Tuple{Integer}" href="#StaticTools.calloc-Tuple{Integer}"><code>StaticTools.calloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calloc([n], size::Integer)</code></pre><p>Libc <code>calloc</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Allocate <code>size</code> bytes of zero-initialized memory and return a pointer to that memory. As <code>malloc</code>, but initializes the memory to all zero.</p><p>See also: <code>malloc</code>, <code>free</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; p = calloc(100*sizeof(Int64))
Ptr{UInt8} @0x00007fb74ff04360

julia&gt; MallocArray{Int64}(p, 10, 10)
10×10 MallocMatrix{Int64}:
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0

julia&gt; free(p)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L25-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.dlclose-Tuple{Ptr{StaticTools.DYLIB}}" href="#StaticTools.dlclose-Tuple{Ptr{StaticTools.DYLIB}}"><code>StaticTools.dlclose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dlclose(lib::Ptr{DYLIB})</code></pre><p>Libc <code>dlclose</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Close a shared library <code>lib</code> given a pointer (handle) previously obtained from <code>StaticTools.dlopen</code>.</p><p>See also: <code>StaticTools.dlopen</code>, <code>StaticTools.dlsym</code>, <code>StaticTools.@ptrcall</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; lib = StaticTools.dlopen(c&quot;libc.dylib&quot;) # on macOS
Ptr{StaticTools.DYLIB} @0x000000010bf49b78

julia&gt; fp = StaticTools.dlsym(lib, c&quot;time&quot;)
Ptr{Nothing} @0x00007fffa773dfa4

julia&gt; dltime() = @ptrcall fp(C_NULL::Ptr{Nothing})::Int
dltime (generic function with 1 method)

julia&gt; dltime()
1654320146

julia&gt; StaticTools.dlclose(lib)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L735-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.dlopen" href="#StaticTools.dlopen"><code>StaticTools.dlopen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dlopen(name::AbstractString, flag=RTLD_LOCAL|RTLD_LAZY)</code></pre><p>Libc <code>dlopen</code> function, accessed by direct <code>llvmcall</code>.</p><p>Returns a handle (pointer) to a <code>.so</code>/<code>.dylib</code> shared library specified by <code>name</code> opened with the mode or combination of modes specified by <code>flag</code>. Returns <code>C_NULL</code> on failure. Valid modes include:</p><p>Required:</p><p><code>RTLD_LOCAL</code> (default): Symbols will not be made available for subsequently loaded libraries. The opposite of <code>RTLD_GLOBAL</code>.</p><p><code>RTLD_GLOBAL</code>: Symbols will be made available for subsequently loaded libraries. The opposite of <code>RTLD_LOCAL</code>.</p><p>Optional:</p><p><code>RTLD_LAZY</code> (default): Lazy binding: only resolve symbols as the code that references them is executed. The opposite of <code>RLTD_NOW</code>.</p><p><code>RTLD_NOW</code>: Eager binding: resolve all symbols before <code>dlopen</code> returns. The opposite of <code>RTLD_LAZY</code></p><p>Modes from the two categories can be combined with bitwise <code>or</code> (<code>|</code>)</p><p>See also: <code>StaticTools.dlsym</code>, <code>StaticTools.@ptrcall</code>, <code>StaticTools.dlclose</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; lib = StaticTools.dlopen(c&quot;libc.dylib&quot;) # on macOS
Ptr{StaticTools.DYLIB} @0x000000010bf49b78

julia&gt; fp = StaticTools.dlsym(lib, c&quot;time&quot;)
Ptr{Nothing} @0x00007fffa773dfa4

julia&gt; dltime() = @ptrcall fp(C_NULL::Ptr{Nothing})::Int
ctime (generic function with 1 method)

julia&gt; dltime()
1654320146

julia&gt; StaticTools.dlclose(lib)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L578-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.dlsym-Tuple{Ptr{StaticTools.DYLIB}, Union{MallocString, MallocArray}}" href="#StaticTools.dlsym-Tuple{Ptr{StaticTools.DYLIB}, Union{MallocString, MallocArray}}"><code>StaticTools.dlsym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dlsym(lib::Ptr{DYLIB}, symbol::AbstractString)</code></pre><p>Libc <code>dlsym</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Takes a handle (<code>lib</code>) to a <code>.so</code>/<code>.dylib</code> shared library previously opened with <code>StaticTools.dlopen</code>, along with a null-terminated symbol name string (<code>symbol</code>), and returns the location in memory of that symbol. Returns <code>C_NULL</code> on failure.</p><p>Optionally, a constant pseudo-pointer <code>RTLD_DEFAULT</code> is  provided which can be used in place of the library <code>lib</code>. This instructs <code>dlsym</code> to search for the next occurrence of the specified <code>symbol</code> in the default search path, starting from the beginning of the search path.</p><p>See also: <code>StaticTools.dlopen</code>, <code>StaticTools.@ptrcall</code>, <code>StaticTools.dlclose</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; lib = StaticTools.dlopen(c&quot;libc.dylib&quot;) # on macOS
Ptr{StaticTools.DYLIB} @0x000000010bf49b78

julia&gt; fp = StaticTools.dlsym(lib, c&quot;time&quot;)
Ptr{Nothing} @0x00007fffa773dfa4

julia&gt; dltime() = @ptrcall fp(C_NULL::Ptr{Nothing})::Int
dltime (generic function with 1 method)

julia&gt; dltime()
1654320146

julia&gt; StaticTools.dlclose(lib)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L667-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.fclose-Tuple{Ptr{StaticTools.FILE}}" href="#StaticTools.fclose-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.fclose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fclose(fp::Ptr{FILE})</code></pre><p>Libc <code>fclose</code> function, accessed by direct <code>llvmcall</code>.</p><p>Closes a file that has been previously opened by <code>fopen</code>, given a file pointer.</p><p>Returns 0 on success.</p><p>See also: <code>fopen</code>, <code>fseek</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.txt&quot;, c&quot;w&quot;)
Ptr{StaticTools.FILE} @0x00007fffc92bd0b0

julia&gt; printf(fp, c&quot;Here is a string&quot;)
16

julia&gt; fclose(fp)
0

shell&gt; cat testfile.txt
Here is a string</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L59-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.fopen-Tuple{Union{MallocString, MallocArray}, Union{MallocString, MallocArray}}" href="#StaticTools.fopen-Tuple{Union{MallocString, MallocArray}, Union{MallocString, MallocArray}}"><code>StaticTools.fopen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fopen(name::AbstractString, mode::AbstractString)</code></pre><p>Libc <code>fopen</code> function, accessed by direct <code>llvmcall</code>.</p><p>Returns a file pointer to a file at location specified by <code>name</code> opened for reading, writing, or both as specified by <code>mode</code>. Valid modes include:</p><p><code>c&quot;r&quot;</code>: Read, from an existing file.</p><p><code>c&quot;w&quot;</code>: Write. If the file exists, it will be overwritten.</p><p><code>c&quot;a&quot;</code>: Append, to the end of an existing file.</p><p>as well as <code>&quot;r+&quot;</code>, <code>c&quot;w+&quot;</code>, and <code>&quot;a+&quot;</code>, which enable both reading and writing.</p><p>See also: <code>fclose</code>, <code>fseek</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.txt&quot;, c&quot;w&quot;)
Ptr{StaticTools.FILE} @0x00007fffc92bd0b0

julia&gt; printf(fp, c&quot;Here is a string&quot;)
16

julia&gt; fclose(fp)
0

shell&gt; cat testfile.txt
Here is a string</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L4-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.fread!-Tuple{Any, AbstractString, Vararg{Any}}" href="#StaticTools.fread!-Tuple{Any, AbstractString, Vararg{Any}}"><code>StaticTools.fread!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fread!(buffer::MallocString, fp::Ptr{FILE}, [n=length(buffer)])
fread!(buffer::MallocArray{T}, fp::Ptr{FILE}, [n=length(buffer)])
fread!(buffer, size::Int64, n::Int64, fp::Ptr{FILE})</code></pre><p>Libc <code>fread</code> function, accessed by direct <code>llvmcall</code>.</p><p>Read <code>n</code> elements of <code>size</code> bytes each from the filestream specified by file pointer <code>fp</code> to the buffer specified as the first argument.</p><p>When not otherwise specified, a <code>size</code> equal to <code>sizeof(eltype(b))</code> is used, or <code>sizeof(UInt8) == 1</code> for strings.</p><p>See also: <code>fwrite</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.b&quot;, c&quot;rwb&quot;)
Ptr{StaticTools.FILE} @0x00007fffa35730c8

julia&gt; fwrite(fp, (1:5)*(1:5)&#39;); frewind(fp)
0

julia&gt; a = szeros(Int,5,5);

julia&gt; fread!(a, fp); a
5×5 StackMatrix{Int64, 25, (5, 5)}:
 1   2   3   4   5
 2   4   6   8  10
 3   6   9  12  15
 4   8  12  16  20
 5  10  15  20  25

julia&gt; fclose(fp)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L755-L792">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.free-Tuple{Ptr}" href="#StaticTools.free-Tuple{Ptr}"><code>StaticTools.free</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free(ptr::Ptr)</code></pre><p>Libc <code>free</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Free memory that has been previously allocated with <code>malloc</code>.</p><p>See also: <code>calloc</code>, <code>malloc</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; p = malloc(500)
Ptr{UInt8} @0x00007ff0e9e74290

julia&gt; free(p)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.fseek" href="#StaticTools.fseek"><code>StaticTools.fseek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fseek(fp::Ptr{FILE}, offset::Int64, whence::Int32=SEEK_CUR)</code></pre><p>Libc <code>fseek</code> function, accessed by direct <code>llvmcall</code>.</p><p>Move position within a file given a file pointer <code>fp</code> obtained from <code>fopen</code>. The new position will be <code>offset</code> bytes (or characters, in the event that all characters are non-unicode ASCII characters encoded as <code>UInt8</code>s) away from the position specified by <code>whence</code>.</p><p>The position reference <code>whence</code> can take on values of either:</p><p>SEEK_SET = Int32(0)           File start</p><p>SEEK_CUR = Int32(1)           Current position</p><p>SEEK_END = Int32(2)           File end</p><p>where <code>SEEK_CUR</code> is the default value.</p><p>Returns 0 on success.</p><p>See also: <code>fopen</code>, <code>fclose</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.txt&quot;, c&quot;w+&quot;)
Ptr{StaticTools.FILE} @0x00007fffc92bd148

julia&gt; printf(fp, c&quot;Here is a string!&quot;)
17

julia&gt; fseek(fp, -2)
0

julia&gt; Char(getc(fp))
&#39;g&#39;: ASCII/Unicode U+0067 (category Ll: Letter, lowercase)

julia&gt; fclose(fp)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L156-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.ftell-Tuple{Ptr{StaticTools.FILE}}" href="#StaticTools.ftell-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.ftell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ftell(fp::Ptr{FILE})</code></pre><p>Libc <code>ftell</code> function, accessed by direct <code>llvmcall</code>.</p><p>Return the current position of the file pointer <code>fp</code>, in bytes from the start of the file.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.txt&quot;, c&quot;w&quot;)
Ptr{StaticTools.FILE} @0x00007fffc92bd0b0

julia&gt; ftell(fp)
0

julia&gt; printf(fp, c&quot;Here is a string&quot;)
16

julia&gt; ftell(fp)
16

julia&gt; fclose(fp)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L106-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.fwrite-Tuple{AbstractString, Vararg{Any}}" href="#StaticTools.fwrite-Tuple{AbstractString, Vararg{Any}}"><code>StaticTools.fwrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fwrite(filepath::AbstractString, data...)
fwrite(fp::Ptr{FILE}, data::AbstractString)
fwrite(fp::Ptr{FILE}, data::AbstractArray{T})
fwrite(fp::Ptr{FILE}, data, size::Int64, n::Int64)</code></pre><p>Libc <code>fwrite</code> function, accessed by direct <code>llvmcall</code>.</p><p>Write <code>n</code> elements of <code>size</code> bytes each to the filestream specified by file pointer <code>fp</code> or name <code>filepath</code> from the string or array <code>data</code>. Where not otherwise specified, a <code>size</code> equal to <code>sizeof(eltype(data))</code> is used, or <code>sizeof(UInt8) == 1</code> for strings.</p><p>See also: <code>fread!</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; fp = fopen(c&quot;testfile.b&quot;, c&quot;rwb&quot;)
Ptr{StaticTools.FILE} @0x00007fffa35730c8

julia&gt; fwrite(fp, (1:5)*(1:5)&#39;); frewind(fp)
0

julia&gt; a = szeros(Int,5,5);

julia&gt; fread!(a, fp); a
5×5 StackMatrix{Int64, 25, (5, 5)}:
 1   2   3   4   5
 2   4   6   8  10
 3   6   9  12  15
 4   8  12  16  20
 5  10  15  20  25

julia&gt; fclose(fp)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L822-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.getc-Tuple{Ptr{StaticTools.FILE}}" href="#StaticTools.getc-Tuple{Ptr{StaticTools.FILE}}"><code>StaticTools.getc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getc(fp::Ptr{FILE})</code></pre><p>Libc <code>getc</code> function, accessed by direct <code>llvmcall</code>.</p><p>Reads a single character from file pointer <code>fp</code>, returning as <code>Int32</code> (<code>-1</code> on EOF).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; getc(stdinp())
c
99</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L560-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.getchar-Tuple{}" href="#StaticTools.getchar-Tuple{}"><code>StaticTools.getchar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getchar()</code></pre><p>Libc <code>getchar</code> function, accessed by direct <code>llvmcall</code>.</p><p>Reads a single character from standard input <code>stdin</code>, returning as <code>UInt8</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; getchar()
c
0x63</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L528-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.gets!" href="#StaticTools.gets!"><code>StaticTools.gets!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gets!(s::MallocString, fp::Ptr{FILE}, n::Integer=length(s))</code></pre><p>Libc <code>fgets</code> function, accessed by direct <code>llvmcall</code>.</p><p>Read up to <code>n</code> characters from the filestream specified by file pointer <code>fp</code> to the MallocString <code>s</code>. Stops when a newline is encountered, end-of-file is reached, or <code>n</code> characters have been read (whichever comes first).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = MallocString(undef, 100)
m&quot;&quot;

julia&gt; gets!(s, stdinp(), 3)
Ptr{UInt8} @0x00007fb15afce550

julia&gt; s
m&quot;
&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L670-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.malloc-Tuple{Integer}" href="#StaticTools.malloc-Tuple{Integer}"><code>StaticTools.malloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">malloc(size::Integer)</code></pre><p>Libc <code>malloc</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Allocate <code>size</code> bytes of memory and return a pointer to that memory.</p><p>See also: <code>calloc</code>, <code>free</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; p = malloc(500)
Ptr{UInt8} @0x00007ff0e9e74290

julia&gt; free(p)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.memcmp-Tuple{Any, Any, Int64}" href="#StaticTools.memcmp-Tuple{Any, Any, Int64}"><code>StaticTools.memcmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">memcmp(a, b, n::Int64)</code></pre><p>Libc <code>memcmp</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Compare the first <code>n</code> bytes of <code>a</code> and <code>b</code>, returning</p><ul><li>a positive value if the first <code>n</code> bytes of <code>a</code> are greater than the first <code>n</code> bytes of <code>b</code></li><li>a negative value if the first <code>n</code> bytes of <code>a</code> are less than the first <code>n</code> bytes of <code>b</code></li><li><code>0</code> the first <code>n</code> bytes of <code>a</code> are equal to the first <code>n</code> bytes of <code>b</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; memcmp(c&quot;foo&quot;, c&quot;foo&quot;, 3)
0

julia&gt; memcmp(c&quot;foo&quot;, c&quot;bar&quot;, 3)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L221-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.memcpy!-Tuple{Any, Any}" href="#StaticTools.memcpy!-Tuple{Any, Any}"><code>StaticTools.memcpy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">memcpy!(a, b, n=length(b))</code></pre><p>Libc <code>memcpy</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Copy <code>n</code> elements from array <code>b</code> to array <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; a = rand(3)
3-element Vector{Float64}:
 0.8559883493421137
 0.4203692766310769
 0.5728354965961716

julia&gt; memcpy!(a, ones(3))
0

julia&gt; a
3-element Vector{Float64}:
 1.0
 1.0
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L172-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.memset!" href="#StaticTools.memset!"><code>StaticTools.memset!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">memset!(a, char::Integer, nbytes::Integer=sizeof(a))</code></pre><p>Libc <code>memset</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Set <code>nbytes</code> bytes of the array or memory region <code>a</code> to the <code>Char</code>/<code>UInt8</code> conversion of the integer <code>char</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; a = rand(5,5)
5×5 Matrix{Float64}:
 0.252808   0.6125    0.947215   0.0966341  0.637651
 0.736149   0.527729  0.928291   0.725644   0.832734
 0.704827   0.990302  0.0380948  0.768337   0.891583
 0.0826808  0.833624  0.364925   0.230345   0.366826
 0.301975   0.113886  0.329196   0.772636   0.0156762

julia&gt; memset!(a, 0)
0

julia&gt; a
5×5 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L100-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.meye-Tuple{Int64}" href="#StaticTools.meye-Tuple{Int64}"><code>StaticTools.meye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">meye([T=Float64,] dims) do A
    ...
end</code></pre><pre><code class="language-julia hljs">meye([T=Float64,] dim::Int)</code></pre><p>Create a <code>MallocArray{T}</code> containing an identity matrix of type <code>T</code>, of size <code>dim</code> x <code>dim</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; A = meye(Int32, 2)

2×2 MallocMatrix{Int32}:
 1  0
 0  1

julia&gt; free(A)
0</code></pre><p>To avoid having to manually <code>free</code> allocated memory, it is recommended to use the following supported do-block syntax whenever possible, i.e.</p><pre><code class="language-julia hljs">julia&gt; meye(2) do A
           printf(A)
       end
1.000000e+00    0.000000e+00
0.000000e+00    1.000000e+00
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L302-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.mfill-Tuple{Any, Vararg{Int64}}" href="#StaticTools.mfill-Tuple{Any, Vararg{Int64}}"><code>StaticTools.mfill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mfill(x::T, dims::Tuple)
mfill(x::T, dims...)</code></pre><p>Create a <code>MallocArray{T}</code> of size <code>dims</code>, filled with the value <code>x</code>, where <code>x</code> is of type <code>T</code>. As <code>Base.fill</code>, but returning a <code>MallocArray</code> instead of an <code>Array</code>.</p><p>See also <code>mzeros</code>, <code>mones</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; mfill(3, 2, 2)
2×2 MallocMatrix{Int64}:
 3  3
 3  3</code></pre><p>To avoid having to manually <code>free</code> allocated memory, it is recommended to use the following supported do-block syntax whenever possible, i.e.</p><pre><code class="language-julia hljs">julia&gt; mfill(1.5, 2,2) do A
           printf(A)
       end
1.500000e+00    1.500000e+00
1.500000e+00    1.500000e+00
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L353-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.mones-Tuple" href="#StaticTools.mones-Tuple"><code>StaticTools.mones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mones([T=Float64,] dims) do A
    ...
end</code></pre><pre><code class="language-julia hljs">mones([T=Float64,] dims::Tuple)
mones([T=Float64,] dims...)</code></pre><p>Create a <code>MallocArray{T}</code> containing all zeros of type <code>T</code>, of size <code>dims</code>. As <code>Base.zeros</code>, but returning a <code>MallocArray</code> instead of an <code>Array</code>.</p><p>See also <code>mzeros</code>, <code>mfill</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; A = mones(Int32, 2,2)
2×2 MallocMatrix{Int32}:
 1  1
 1  1

julia&gt; free(A)
0</code></pre><p>To avoid having to manually <code>free</code> allocated memory, it is recommended to use the following supported do-block syntax whenever possible, i.e.</p><pre><code class="language-julia hljs">julia&gt; mones(2,2) do A
           printf(A)
       end
1.000000e+00    1.000000e+00
1.000000e+00    1.000000e+00
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L257-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.mzeros-Tuple{Vararg{Int64}}" href="#StaticTools.mzeros-Tuple{Vararg{Int64}}"><code>StaticTools.mzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mzeros([T], dims) do A
    ...
end</code></pre><pre><code class="language-julia hljs">mzeros([T=Float64,] dims::Tuple)
mzeros([T=Float64,] dims...)</code></pre><p>Create a <code>MallocArray{T}</code> containing all zeros of type <code>T</code>, of size <code>dims</code>. As <code>Base.zeros</code>, but returning a <code>MallocArray</code> instead of an <code>Array</code>.</p><p>See also <code>mones</code>, <code>mfill</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; mzeros(Int32, 2,2)
2×2 MallocMatrix{Int32}:
 0  0
 0  0</code></pre><p>To avoid having to manually <code>free</code> allocated memory, it is recommended to use the following supported do-block syntax whenever possible, i.e.</p><pre><code class="language-julia hljs">julia&gt; mzeros(2,2) do A
           printf(A)
       end
0.000000e+00    0.000000e+00
0.000000e+00    0.000000e+00
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocarray.jl#L213-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.newline-Tuple{}" href="#StaticTools.newline-Tuple{}"><code>StaticTools.newline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newline([fp::Ptr{FILE}])</code></pre><p>Prints a single newline (<code></code>) to a file pointer <code>fp</code>, defaulting  to <code>stdout</code> if not specified.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; putchar(&#39;C&#39;)
0

julia&gt; newline() # flushes stdout
C
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L503-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.parsedlm-Tuple{Any, Char}" href="#StaticTools.parsedlm-Tuple{Any, Char}"><code>StaticTools.parsedlm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parsedlm([T::Type], filepath::String, delimiter::Char)</code></pre><p>Parse a delimited text file, given a <code>filepath</code> and <code>delimiter</code>, and return the parsed contents as a <code>MallocMatrix{T}</code>, that is a 2D <code>MallocArray</code> containing numbers of type <code>T</code>.</p><p>If not specified, the parse type <code>T</code> will default to <code>Float64</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using StaticTools

julia&gt; m = (1:10) * (1:10)&#39;;

julia&gt; fp = fopen(c&quot;testfile.tsv&quot;, c&quot;w&quot;); printf(fp, m); fclose(fp);

julia&gt; parsedlm(Int32, c&quot;testfile.tsv&quot;, &#39;	&#39;)
10×10 MallocMatrix{Int32}:
  1   2   3   4   5   6   7   8   9   10
  2   4   6   8  10  12  14  16  18   20
  3   6   9  12  15  18  21  24  27   30
  4   8  12  16  20  24  28  32  36   40
  5  10  15  20  25  30  35  40  45   50
  6  12  18  24  30  36  42  48  54   60
  7  14  21  28  35  42  49  56  63   70
  8  16  24  32  40  48  56  64  72   80
  9  18  27  36  45  54  63  72  81   90
 10  20  30  40  50  60  70  80  90  100</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/parsedlm.jl#L2-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.perror-Tuple{MallocString}" href="#StaticTools.perror-Tuple{MallocString}"><code>StaticTools.perror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perror(s)</code></pre><p>Print the string <code>s</code> to the standard error filestream, <code>stderr</code>.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; StaticTools.perror(c&quot;ERROR: could not do thing
&quot;)
ERROR: could not do thing
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/printformats.jl#L256-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.printdlm" href="#StaticTools.printdlm"><code>StaticTools.printdlm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printdlm(filepath, data, [delim=&#39;	&#39;])</code></pre><p>Print a vector or matrix <code>data</code> as delimited ASCII text to a new file <code>name</code> with delimiter <code>delim</code> Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; a = szeros(3,3)
3×3 StackMatrix{Float64, 9, (3, 3)}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; printdlm(c&quot;foo.csv&quot;, a, &#39;,&#39;)
0

shell&gt; cat foo.csv
0.000000e+00,0.000000e+00,0.000000e+00,
0.000000e+00,0.000000e+00,0.000000e+00,
0.000000e+00,0.000000e+00,0.000000e+00,

julia&gt; parsedlm(c&quot;foo.csv&quot;, &#39;,&#39;)
3×3 MallocMatrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/printformats.jl#L292-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.printf-Tuple{MallocString}" href="#StaticTools.printf-Tuple{MallocString}"><code>StaticTools.printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printf ([fp::Ptr{FILE}], [fmt::AbstractString], s)</code></pre><p>Libc <code>printf</code> function, accessed by direct <code>llvmcall</code>.</p><p>Prints a string <code>s</code> (specified either as a raw <code>Ptr{UInt8}</code> to a valid null-terminated string in memory or else a string type such as <code>StaticString</code> or <code>MallocString</code> for which a valid pointer can be obtained) to a filestream specified by the file pointer <code>fp</code>, defaulting to the current standard output <code>stdout</code> if not specified.</p><p>Optionally, a C-style format specifier string <code>fmt</code> may be provided as well.</p><p>Returns the number of characters printed on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; printf(c&quot;Hello there!
&quot;)
Hello there!
13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L947-L970">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.printf-Tuple{T} where T&lt;:Union{Number, Ptr}" href="#StaticTools.printf-Tuple{T} where T&lt;:Union{Number, Ptr}"><code>StaticTools.printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printf([fp::Ptr{FILE}], [fmt], n::Number)</code></pre><p>Libc <code>printf</code> function, accessed by direct <code>llvmcall</code>.</p><p>Prints a number <code>n</code> to a filestream specified by the file pointer <code>fp</code>, defaulting to the current standard output <code>stdout</code> if not specified.</p><p>Optionally, a C-style format specifier string <code>fmt</code> may be provided as well.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; printf(1)
1
0

julia&gt; printf(1/3)
3.333333e-01
0

julia&gt; printf(c&quot;%f
&quot;, 1/3)
0.333333
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/printformats.jl#L14-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.printf-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{Number, Ptr, StaticString}" href="#StaticTools.printf-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Union{Number, Ptr, StaticString}"><code>StaticTools.printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printf([fp::Ptr{FILE}], a::AbstractArray{&lt;:Number})</code></pre><p>Print a matrix or vector of numbers <code>a</code> to a filestream specified by the file pointer <code>fp</code>, defaulting to the current standard output <code>stdout</code> if not specified.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; printf(rand(5,5))
5.500186e-02    8.425572e-01    3.871220e-01    5.442254e-01    5.990694e-02
5.848425e-01    6.714915e-01    5.616896e-01    6.668248e-01    2.643873e-01
9.156712e-01    1.276033e-01    3.350369e-01    6.513146e-01    9.999104e-01
3.301038e-01    6.027120e-01    5.139433e-01    2.219796e-01    4.057417e-01
2.821340e-01    9.258760e-01    7.950481e-01    1.152236e-01    7.949463e-01
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/printformats.jl#L47-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.printf-Union{Tuple{Tuple{T1, T2}}, Tuple{T2}, Tuple{T1}} where {T1, T2}" href="#StaticTools.printf-Union{Tuple{Tuple{T1, T2}}, Tuple{T2}, Tuple{T1}} where {T1, T2}"><code>StaticTools.printf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printf([fp::Ptr{FILE}], things::Tuple)</code></pre><p>Print any number of things, optionally to a file specified by <code>fp</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; printf((c&quot;Sphinx &quot;, c&quot;of &quot;, c&quot;black &quot;, c&quot;quartz, &quot;, c&quot;judge &quot;, c&quot;my &quot;, c&quot;vow!
&quot;))
Sphinx of black quartz, judge my vow!
0

julia&gt; x = 1
1

julia&gt; printf((c&quot;The value of x is currently &quot;, x, c&quot;
&quot;))
The value of x is currently 1
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/printformats.jl#L157-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.putchar-Tuple{Char}" href="#StaticTools.putchar-Tuple{Char}"><code>StaticTools.putchar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">putchar([fp::Ptr{FILE}], c::Union{Char,UInt8})</code></pre><p>Libc <code>putchar</code> / <code>fputc</code> function, accessed by direct <code>llvmcall</code>.</p><p>Prints a single character <code>c</code> (either a <code>Char</code> or a raw <code>UInt8</code>) to a file pointer <code>fp</code>, defaulting to the current standard output <code>stdout</code> if not specified.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; putchar(&#39;C&#39;)
0

julia&gt; putchar(0x63)
0

julia&gt; putchar(&#39;
&#39;) # Newline, flushes stdout
Cc
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L440-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.puts-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.puts-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.puts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">puts([fp::Ptr{FILE}], s::AbstractString)</code></pre><p>Libc <code>puts</code>/<code>fputs</code> function, accessed by direct <code>llvmcall</code>.</p><p>Prints a string <code>s</code> (specified either as a raw <code>Ptr{UInt8}</code> to a valid null-terminated string in memory or elseor else a string type such as <code>StaticString</code> or <code>MallocString</code> for which a valid pointer can be obtained) followed by a newline (<code></code>) to a filestream specified by the file pointer <code>fp</code>, defaulting to the current standard output <code>stdout</code> if not specified.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; puts(c&quot;Hello there!&quot;)
Hello there!
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L601-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.seye-Tuple{Int64}" href="#StaticTools.seye-Tuple{Int64}"><code>StaticTools.seye</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seye([T=Float64,] dim::Int)</code></pre><p>Create a <code>StackArray{T}</code> containing an identity matrix of type <code>T</code>, of size <code>dim</code> x <code>dim</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; seye(Int32, 2)
2×2 StackMatrix{Int32, 4, (2, 2)}:
 1  0
 0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L196-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.sfill-Tuple{Any, Vararg{Int64}}" href="#StaticTools.sfill-Tuple{Any, Vararg{Int64}}"><code>StaticTools.sfill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sfill(x::T, dims::Tuple)
sfill(x::T, dims...)</code></pre><p>Create a <code>StackArray{T}</code> of size <code>dims</code>, filled with the value <code>x</code>, where <code>x</code> is of type <code>T</code>. As <code>Base.fill</code>, but returning a <code>StackArray</code> instead of an <code>Array</code>.</p><p>See also <code>szeros</code>, <code>sones</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sfill(3, 2, 2)
2×2 StackMatrix{Int64, 4, (2, 2)}:
 3  3
 3  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L222-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.sones-Tuple" href="#StaticTools.sones-Tuple"><code>StaticTools.sones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">szeros([T=Float64,] dims::Tuple)
szeros([T=Float64,] dims...)</code></pre><p>Create a <code>StackArray{T}</code> containing all zeros of type <code>T</code>, of size <code>dims</code>. As <code>Base.zeros</code>, but returning a <code>StackArray</code> instead of an <code>Array</code>.</p><p>See also <code>sones</code>, <code>sfill</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; szeros(Int32, 2,2)
2×2 StackMatrix{Int32, 4, (2, 2)}:
 0  0
 0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L154-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.splitmix64" href="#StaticTools.splitmix64"><code>StaticTools.splitmix64</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splitmix64([rng::SplitMix64])</code></pre><p>A StaticCompiler-safe (non-allocating) implementation of the SplitMix64 deterministic pseudorandom number generator.</p><p><strong>See also:</strong></p><p><code>SplitMix64</code>, <code>rand</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; seed = StaticTools.time() # Pick a seed
1649890154

julia&gt; rng = SplitMix64(seed) # Initialize the generator
SplitMix64{Int64}((1649890154,))

julia&gt; splitmix64(rng) # Draw a pseudorandom `UInt64` from the generator
0xca764ac7b7ea31e8

julia&gt; rand(rng) # Draw a `Float64` between 0 and 1
0.8704883051360292</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticrng.jl#L44-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.static_rng" href="#StaticTools.static_rng"><code>StaticTools.static_rng</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">static_rng([seed::Bits64])</code></pre><p>Initialize a StaticCompiler-safe (non-allocating) deterministic pseudorandom number generator, optionally specifying a 64-bit <code>seed</code> (which may be any 64-bit primitive numeric type – that is, <code>Float64</code>, <code>Int64</code>, or <code>UInt64</code>).</p><p>In particular, <code>static_rng</code> uses the specified <code>seed</code> value (or if not specified, the current result of <code>StaticTools.time()</code>) to initialize a simple <code>SplitMix64</code> generator, which is then in turn used to bootstrap the larger seed required for a <code>Xoshiro256✴︎✴︎</code> generator.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; rng = static_rng()
Xoshiro256✴︎✴︎{UInt64}((0x2d4c7aa97cc1a621, 0x63460fc58ff25249, 0x81498572d44bd2ec, 0x2d4e96d3a7e9fdd2))

julia&gt; rand(rng) # Draw a `Float64` between 0 and 1
0.6577585429879329

julia&gt; rand(rng)
0.4711097758403277</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticrng.jl#L172-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.static_type-Tuple{Any}" href="#StaticTools.static_type-Tuple{Any}"><code>StaticTools.static_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">static_type(ctx::StaticContext, x)
static_type(x)</code></pre><p>Returns an object similar to <code>x</code> with contents converted based on rules  specified by <code>ctx</code>. <code>static_type</code> can be used for types or for objects.</p><p>For the default case, this converts <code>Array</code>s to <code>MallocArray</code>s and  <code>String</code>s to <code>MallocString</code>s.</p><p>To define your own rules, create a new <code>StaticContext</code> and then define two versions of <code>static_type</code> for each type you would like to convert. One converts the value, and one converts the type. Here is the builtin example for converting Arrays:</p><pre><code class="nohighlight hljs">struct MyCtx &lt;: StaticContext end
static_type(ctx::MyCtx, x::Array) = MallocArray(x)
static_type(ctx::MyCtx, ::Type{Array{T,N}}) where {T,N} = MallocArray{T,N}</code></pre><p>For this context struct, inherit from <code>StaticTools.DefaultStaticContext</code> to build on the defaults, or inherit from <code>StaticTools.StaticContext</code> to define rules from scratch.</p><p><code>static_type</code> is mainly useful for converting objects that are heavily  paramaterized. The SciML infrastructure has a lot of this. The main objects like a <code>DiffEq.Integrator</code> has many type parameters, and by default, some are not amenable to static compilation. <code>static_type</code> can be used to convert them to forms that can help numerical code to be statically compiled.</p><p><code>static_type</code> cannot convert all objects automatically. It transforms all type parameters and the contents of each field in an object  (recursively). But, some objects do not define a &quot;fully specified&quot;  constructor. In some cases, another method, <code>static_type_contents</code> can help by returning the components to help for a manual invocation of the constructor.</p><p>Note that any <code>Malloc</code>-objects created through this function must still be  <code>free</code>d manually if you do not wish to leak memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/static_type.jl#L6-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.static_type_contents-Tuple{Any}" href="#StaticTools.static_type_contents-Tuple{Any}"><code>StaticTools.static_type_contents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">static_type_contents(ctx::StaticContext, x)
static_type_contents(x)</code></pre><p>Returns a tuple with:</p><ul><li>a vector of type parameters for <code>x</code> transformed by <code>static_type</code></li><li>a vector of the contents of the fields in <code>x</code> transformed by  <code>static_type</code></li></ul><p>Results can be useful for defining objects that do not define a  fully specified constructor. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/static_type.jl#L74-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.stderrp-Tuple{}" href="#StaticTools.stderrp-Tuple{}"><code>StaticTools.stderrp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stderrp()</code></pre><p>Zero-argument function which returns a raw pointer to the current standard error filestream, <code>stderr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; stderrp()
Ptr{StaticTools.FILE} @0x00007fffc92b9240

julia&gt; printf(stderrp(), c&quot;Hi there!
&quot;)
Hi there!
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L305-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.stdinp-Tuple{}" href="#StaticTools.stdinp-Tuple{}"><code>StaticTools.stdinp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stdinp()</code></pre><p>Zero-argument function which returns a raw pointer to the current standard input filestream, <code>stdin</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; stdinp()
Ptr{StaticTools.FILE} @0x00007fffc92b9110</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L374-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.stdoutp-Tuple{}" href="#StaticTools.stdoutp-Tuple{}"><code>StaticTools.stdoutp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stdoutp()</code></pre><p>Zero-argument function which returns a raw pointer to the current standard output filestream, <code>stdout</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; stdoutp()
Ptr{StaticTools.FILE} @0x00007fffc92b91a8

julia&gt; printf(stdoutp(), c&quot;Hi there!
&quot;)
Hi there!
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmio.jl#L236-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.strlen-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.strlen-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strlen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strlen(s)</code></pre><p>Libc <code>strlen</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Returns the length in bytes of the null-terminated string <code>s</code>, not counting the terminating null character.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; strlen(&quot;foo&quot;) # Not documented, but Julia strings are null-terminated in practice every time I&#39;ve checked
3

julia&gt; strlen(c&quot;foo&quot;)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L365-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.strtod-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.strtod-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strtod(s)</code></pre><p>Libc <code>strtod</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Returns a <code>Float64</code> (&quot;double&quot;) containing the number written out in decimal form in null-terminated string <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; num, pbuf = StaticTools.strtod(c&quot;3.1415&quot;)
(3.1415, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000010aeee946,)))

julia&gt; num, pbuf = StaticTools.strtod(c&quot;5&quot;)
(5.0, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000010d8f2bb1,)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L403-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.strtol-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.strtol-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strtol(s)</code></pre><p>Libc <code>strtol</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Returns an <code>Int64</code> (&quot;long&quot;) containing the number written out in decimal form in null-terminated string <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; num, pbuf = StaticTools.strtol(c&quot;3.1415&quot;)
(3, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000010dd827f1,)))

julia&gt; num, pbuf = StaticTools.strtol(c&quot;5&quot;)
(5, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000015dbdda41,)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L446-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.strtoul-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.strtoul-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.strtoul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strtoul(s)</code></pre><p>Libc <code>strtol</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Returns an <code>UInt64</code> (&quot;unsigned long&quot;) containing the number written out in decimal form in null-terminated string <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; num, pbuf = StaticTools.strtoul(c&quot;3.1415&quot;)
(0x0000000000000003, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000010d6976a1,)))

julia&gt; num, pbuf = StaticTools.strtoul(c&quot;5&quot;)
(0x0000000000000005, ManualMemory.MemoryBuffer{1, Ptr{UInt8}}((Ptr{UInt8} @0x000000015ed45d11,)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L489-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.system-Tuple{Union{MallocString, MallocArray}}" href="#StaticTools.system-Tuple{Union{MallocString, MallocArray}}"><code>StaticTools.system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">system(s)</code></pre><p>Libc <code>system</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Pass the null-terminated string (or pointer thereto) <code>s</code> to the libc <code>system</code> function for evaluation.</p><p>Returns <code>0</code> on success.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; StaticTools.system(c&quot;time echo hello&quot;)
hello

real    0m0.001s
user    0m0.000s
sys 0m0.000s
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L324-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.szeros-Tuple" href="#StaticTools.szeros-Tuple"><code>StaticTools.szeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sones([T=Float64,] dims::Tuple)
sones([T=Float64,] dims...)</code></pre><p>Create a <code>StackArray{T}</code> containing all zeros of type <code>T</code>, of size <code>dims</code>. As <code>Base.zeros</code>, but returning a <code>StackArray</code> instead of an <code>Array</code>.</p><p>See also <code>szeros</code>, <code>sfill</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sones(Int32, 2,2)
2×2 StackMatrix{Int32, 4, (2, 2)}:
 1  1
 1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/stackarray.jl#L175-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.time-Tuple{}" href="#StaticTools.time-Tuple{}"><code>StaticTools.time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time()</code></pre><p>Libc <code>time</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Return, as an <code>Int64</code>, the current time in seconds since the beginning of the current Unix epoch on 00:00:00 UTC, January 1, 1970.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; StaticTools.time()
1651105298</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L262-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.usleep-Tuple{Integer}" href="#StaticTools.usleep-Tuple{Integer}"><code>StaticTools.usleep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">usleep(μsec::Integer)</code></pre><p>Libc <code>usleep</code> function, accessed by direct StaticCompiler-safe <code>llvmcall</code>.</p><p>Suspend execution of the calling thread for (at least) μsec microseconds.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; usleep(1000000)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvmlibc.jl#L292-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.xoshiro256✴︎✴︎-Tuple{StaticTools.StaticRNG{4}}" href="#StaticTools.xoshiro256✴︎✴︎-Tuple{StaticTools.StaticRNG{4}}"><code>StaticTools.xoshiro256✴︎✴︎</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xoshiro256✴︎✴︎(rng::Xoshiro256✴︎✴︎)</code></pre><p>A StaticCompiler-safe (non-allocating) implementation of the Xoshiro256✴︎✴︎ deterministic pseudorandom number generator, written in LLVM IR and invoked via <code>llvmcall</code>.</p><p><strong>See also:</strong></p><p><code>Xoshiro256✴︎✴︎</code>, <code>static_rng</code>, <code>rand</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; seed = (0x9b134eccd2e63538, 0xd74ab64b2c3ecc9b, 0x70ba9c07628c27bf, 0x270a2eb658e6130b);

julia&gt; rng = Xoshiro256✴︎✴︎(seed) # Initialize the generator
Xoshiro256✴︎✴︎{UInt64}((0x9b134eccd2e63538, 0xd74ab64b2c3ecc9b, 0x70ba9c07628c27bf, 0x270a2eb658e6130b))

julia&gt; xoshiro256✴︎✴︎(rng) # Draw a pseudorandom `UInt64` from the generator
0x11059b6384fba06a

julia&gt; rand(rng) # Draw a `Float64` between 0 and 1
0.9856766307398369</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticrng.jl#L117-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@c_str-Tuple{Any}" href="#StaticTools.@c_str-Tuple{Any}"><code>StaticTools.@c_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@c_str -&gt; StaticString</code></pre><p>Construct a <code>StaticString</code>, such as <code>c&quot;Foo&quot;</code>.</p><p>A <code>StaticString</code> should generally behave like a base Julia <code>String</code>, but is explicitly null-terminated, mutable, and standalone-StaticCompiler safe (does not require libjulia).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; c&quot;Hello there!&quot;
c&quot;Hello there!&quot;

julia&gt; c&quot;foo&quot; == &quot;foo&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/staticstring.jl#L90-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@externload-Tuple{Any}" href="#StaticTools.@externload-Tuple{Any}"><code>StaticTools.@externload</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@externload symbol::T</code></pre><p>Load an LLVM <code>external global</code> variable with name <code>symbol</code> and type <code>T</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; foo() = @externload __stderrp::Ptr{UInt8} # macos syntax
foo (generic function with 1 method)

julia&gt; foo()
Ptr{UInt8} @0x00007fffadb8a240

julia&gt; foo() == stderrp()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvminterop.jl#L269-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@externptr-Tuple{Any}" href="#StaticTools.@externptr-Tuple{Any}"><code>StaticTools.@externptr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@externptr symbol::T</code></pre><p>Return the pointer to an LLVM <code>external global</code> variable with name <code>symbol</code> and type <code>T</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; foo() = @externptr __stderrp::Ptr{UInt8} # macos syntax
foo (generic function with 1 method)

julia&gt; foo()
Ptr{Ptr{UInt8}} @0x00007fffadb8a9a0

julia&gt; Base.unsafe_load(foo()) == stderrp()
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvminterop.jl#L225-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@m_str-Tuple{Any}" href="#StaticTools.@m_str-Tuple{Any}"><code>StaticTools.@m_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@m_str -&gt; MallocString</code></pre><p>Construct a <code>MallocString</code>, such as <code>m&quot;Foo&quot;</code>.</p><p>A <code>MallocString</code> should generally behave like a base Julia <code>String</code>, but is explicitly null-terminated, mutable, standalone-StaticCompiler-safe (does not require libjulia) and is backed by <code>malloc</code>d memory which is not tracked by the GC and should be <code>free</code>d when no longer in use.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; s = m&quot;Hello there!&quot;
m&quot;Hello there!&quot;

julia&gt; s == &quot;Hello there!&quot;
true

julia&gt; free(s)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/mallocstring.jl#L125-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@ptrcall-Tuple{Any}" href="#StaticTools.@ptrcall-Tuple{Any}"><code>StaticTools.@ptrcall</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ptrcall function_pointer(argvalue1::Type1, ...)::ReturnType</code></pre><p>Call a function pointer (e.g., as obtained from <code>dlsym</code>) via macro-constructed <code>llvmcall</code>.</p><p>See also: <code>StaticTools.dlopen</code>, <code>StaticTools.dlsym</code>, <code>StaticTools.dlclose</code> c.f.: <code>@ccall</code>, <code>StaticTools.@symbolcall</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; lib = StaticTools.dlopen(c&quot;libc.dylib&quot;) # on macOS
Ptr{StaticTools.DYLIB} @0x000000010bf49b78

julia&gt; fp = StaticTools.dlsym(lib, c&quot;time&quot;)
Ptr{Nothing} @0x00007fffa773dfa4

julia&gt; dltime() = @ptrcall fp(C_VOID::Ptr{Nothing})::Int
dltime (generic function with 1 method)

julia&gt; dltime()
1654320146

julia&gt; StaticTools.dlclose(lib)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvminterop.jl#L25-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StaticTools.@symbolcall-Tuple{Any}" href="#StaticTools.@symbolcall-Tuple{Any}"><code>StaticTools.@symbolcall</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@symbolcall symbol(argvalue1::Type1, ...)::ReturnType</code></pre><p>Call a function by symbol/name in LLVM IR, via macro-constructed <code>llvmcall</code></p><p>See also: <code>@ccall</code>, <code>StaticTools.@ptrcall</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; ctime() = @symbolcall time()::Int
ctime (generic function with 1 method)

julia&gt; ctime()
1654322507

julia&gt; @macroexpand @symbolcall time()::Int
:(Base.llvmcall((&quot;declare i64 @time()

define i64 @main() #0 {
  
  %result = call i64 () @time()
  ret i64 %result
}
attributes #0 = { alwaysinline nounwind ssp uwtable }
&quot;, &quot;main&quot;), Int, Tuple{}))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/brenhinkeller/StaticTools.jl/blob/f3f36597eb66cdbd44bd30c46ddb2321b6b8772c/src/llvminterop.jl#L129-L156">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 20 May 2024 15:45">Monday 20 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
